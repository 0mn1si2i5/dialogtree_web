# DialogTree 前端开发说明

## 📋 项目概述

DialogTree 是一个支持对话分叉的智能对话系统，用户可以从任意历史对话点开始新的分支对话，形成树状的对话结构。

## 🏗️ 核心概念

### 数据结构层次
```
Session (会话)
  └── Dialog (对话分支)
      └── Conversation (具体对话)
```

- **Session**: 一个主题会话，包含多个Dialog分支
- **Dialog**: 对话分支，形成树状结构，可以有父子关系
- **Conversation**: 具体的一问一答，属于某个Dialog

### 分叉机制
当用户从历史对话中的某个点开始新对话时：
1. 系统检测是否需要分叉（选择的不是最新对话）
2. 如需分叉，创建新的Dialog分支
3. 将该点之后的对话移动到另一个分支
4. 在新分支中添加用户的新对话

## 🔌 API 接口

### 基础URL
```
http://localhost:8080/api/v1
```

### 核心接口

#### 1. 新建对话
```http
POST /dialog/chat
Content-Type: application/json

{
  "content": "用户输入的问题",
  "sessionId": 123,
  "parentConversationId": 456  // 可选，指定从哪个conversation继续对话
}
```

**响应**: Server-Sent Events (SSE) 流式响应
```
data: {"type": "message", "content": "AI回答的片段"}
data: {"type": "message", "content": "更多内容"}
data: {"type": "done", "data": {"dialogId": 789, "conversationId": 101}}
```

#### 2. 同步对话（测试用）
```http
POST /dialog/chat-sync
Content-Type: application/json

{
  "content": "用户问题",
  "sessionId": 123,
  "parentConversationId": 456
}
```

**响应**:
```json
{
  "code": 200,
  "data": {
    "dialogId": 789,
    "conversationId": 101,
    "title": "对话标题",
    "summary": "对话摘要"
  },
  "message": "对话成功"
}
```

#### 3. 获取会话对话树
```http
GET /session/{sessionId}/dialogs
```

**响应**:
```json
{
  "code": 200,
  "data": [
    {
      "id": 1,
      "sessionId": 123,
      "parentId": null,
      "createdAt": "2024-01-01T10:00:00Z",
      "conversationModels": [
        {
          "id": 1,
          "prompt": "用户问题",
          "answer": "AI回答",
          "title": "对话标题",
          "summary": "对话摘要",
          "isStarred": false,
          "comment": "",
          "createdAt": "2024-01-01T10:00:00Z"
        }
      ]
    }
  ]
}
```

#### 4. 会话管理
```http
# 获取会话列表
GET /session/list

# 创建新会话
POST /session/create
{
  "title": "会话标题",
  "categoryId": 1
}

# 删除会话
DELETE /session/{sessionId}
```

#### 5. 对话操作
```http
# 标星/取消标星
PUT /dialog/conversation/{conversationId}/star

# 更新评论
PUT /dialog/conversation/{conversationId}/comment
{
  "comment": "用户评论"
}
```

## 🎨 前端设计要点

### 1. 对话树可视化
- 使用树状结构展示Dialog关系
- 每个Dialog分支显示其包含的Conversations
- 支持折叠/展开分支
- 高亮当前活跃分支

### 2. 分叉交互设计
```javascript
// 从某个conversation开始新对话的流程
function startConversationFromPoint(conversationId, userInput) {
  // 1. 发送请求时指定parentConversationId
  const response = await fetch('/api/v1/dialog/chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      content: userInput,
      sessionId: currentSessionId,
      parentConversationId: conversationId  // 关键参数
    })
  });
  
  // 2. 处理SSE流式响应
  // 3. 更新UI显示新的分支
}
```

### 3. 实时流式显示
```javascript
// SSE处理示例
function handleStreamResponse(response) {
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  function readChunk() {
    return reader.read().then(({ done, value }) => {
      if (done) return;
      
      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');
      
      lines.forEach(line => {
        if (line.startsWith('data: ')) {
          const content = line.substring(6);
          if (content === '[DONE]') {
            // 流结束
            return;
          }
          // 显示内容片段
          appendToCurrentMessage(content);
        }
      });
      
      return readChunk();
    });
  }
  
  return readChunk();
}
```

### 4. 状态管理建议

```javascript
// 建议的状态结构
const appState = {
  currentSession: {
    id: 123,
    title: "会话标题",
    dialogs: [
      {
        id: 1,
        parentId: null,
        conversations: [
          {
            id: 1,
            prompt: "问题",
            answer: "回答",
            title: "标题",
            summary: "摘要",
            isStarred: false,
            createdAt: "2024-01-01T10:00:00Z"
          }
        ]
      }
    ]
  },
  currentDialog: 1,  // 当前活跃的dialog
  isStreaming: false,  // 是否正在接收流式响应
  streamingContent: "",  // 当前流式内容
}
```

## ⚠️ 重要注意事项

### 1. 分叉逻辑处理
- 当`parentConversationId`不是当前Dialog的最新conversation时，后端会自动创建分叉
- 前端需要处理分叉后的UI更新，可能需要重新获取整个Dialog树
- 分叉操作是事务性的，要么全部成功要么全部失败

### 2. 流式响应处理
- 使用SSE处理实时流式输出
- 需要正确处理连接断开和重连
- 流式内容可能包含特殊字符，注意转义

### 3. 错误处理
```javascript
// 常见错误响应
{
  "code": 400,
  "message": "参数错误",
  "data": null
}

// 需要处理的错误场景
- 网络连接失败
- 会话不存在
- 分叉创建失败
- AI服务不可用
```

### 4. 性能优化
- 大型对话树使用虚拟滚动
- 懒加载历史对话内容
- 缓存Dialog结构，避免频繁请求
- 流式响应时控制DOM更新频率

### 5. 用户体验
- 分叉操作要有明确的视觉反馈
- 支持快速跳转到任意对话点
- 提供对话搜索和过滤功能
- 标星和评论功能要易于访问

## 🔧 开发工具建议

### 测试API
```bash
# 使用curl测试同步接口
curl -X POST http://localhost:8080/api/v1/dialog/chat-sync \
  -H "Content-Type: application/json" \
  -d '{"content":"测试问题","sessionId":1}'

# 测试SSE接口
curl -N http://localhost:8080/api/v1/dialog/chat \
  -H "Content-Type: application/json" \
  -d '{"content":"测试问题","sessionId":1}'
```

## 📝 开发检查清单

- [ ] 会话列表展示
- [ ] 对话树可视化
- [ ] 从任意点开始新对话
- [ ] 流式响应显示
- [ ] 分叉后UI正确更新
- [ ] 标星和评论功能
- [ ] 错误处理和用户反馈
- [ ] 响应式设计
- [ ] 性能优化
- [ ] 键盘快捷键支持

## 🐛 调试提示

1. **分叉不工作**: 检查`parentConversationId`是否正确传递
2. **流式响应中断**: 检查SSE连接处理和错误重连机制
3. **对话树显示错误**: 验证Dialog的parent-child关系是否正确解析
4. **性能问题**: 使用浏览器开发工具分析DOM更新和内存使用